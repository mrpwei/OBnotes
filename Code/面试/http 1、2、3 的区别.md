### http/1.0 与 http/1.1

- 1.1版本最大变化就是引入了持久连接，及TCP连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`,明确要求服务器关闭连接。而1.0版本每次连接都需要三次握手。

- 1.1版本还引入了管道机制，即在同一个TCP连接里，客户端可以同时发送多个请求，进一步提升了http协议的效率。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。问题，要是前面的回应特别慢，后面就会有许多请求排毒等着，这称为「队头阻塞」。「队头阻塞」的模式加剧了HTTP的性能问题。总之HTTP/1.1 的性能一般般，后续的HTTP/2 和HTTP/3 就是在优化HTTP的性能。

### http2

http1.1的问题：
1. 请求/响应头未经压缩发送，头部信息越多延迟越大，只能压缩body部分；
2. 服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据，也就是对头阻塞；
3. 没有请求优先级控制；
4. 请求只能从客户端开始，服务器只能被动响应。

http2的改进：
1. 会通过Hpack算法压缩头部；[HTTP/2 头部压缩技术介绍 - 掘金 (juejin.cn)](https://juejin.cn/post/7133238781452222472)
2. 不再是纯文本的报文，而是采用二进制，称为帧：头信息帧和数据帧；
3. 数据包不是按顺序发送，客户端还可以指定数据流的优先级；
4. 可以并发多个请求，而不用按顺序一一响应。解决了「对头阻塞」问题。比如：在一个TCP连接里，服务器收到了客户端A和B的两个请求，如果发现A处理过程非常耗时，于是就回应A请求已经处理好的部分，接着回应B请求，完成后，再回应A请求剩下的部分。
5. 服务器推送，HTTP/2在一定程度上改善了传统的「请求-应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。比如：在浏览器刚请求HTML的时候，就提前把可能用到的JS、CSS文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫Cache Push）

### http3

http2的问题：
多个http请求复用同一个tcp连接，下层的tcp协议是不知道有多少个http请求的。因此一旦发生丢包现象，就会触发tcp的重传机制，这样一个tcp连接里的所有http请求都必须等待这个丢了的包被重传回来。

因此，http3把http下层的tcp协议改成了udp。


参考：
- [HTTP/1.0、HTTP/1.1、HTTP/2、HTTP/3的区别_timchen525的博客-CSDN博客_http/1.3](https://blog.csdn.net/timchen525/article/details/108461413)